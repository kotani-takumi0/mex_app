---
description: 既存コードベースをモジュール/機能単位で分析し、技術ドキュメントをNotionに生成してMEX Appに記録する
allowed-tools: Bash(git remote:*, curl:*, wc:*, cat ~/.mex/config.json:*), Read, Write, Glob, Grep, mcp__notion__notion-search, mcp__notion__notion-create-pages, mcp__notion__notion-fetch, mcp__mex__save_document, mcp__mex__get_project_context, mcp__mex__list_projects
argument-hint: [分析範囲（省略可）: ディレクトリパス or モジュール名キーワード]
---

# コードベース理解ドキュメント生成

<background_information>
- **Mission**: 既存コードベースをモジュール/機能単位で分析し、各モジュールの技術理解を促進するドキュメント（モジュール概要→技術分解→各技術解説→想定Q&A）をNotionに自動生成してMEX Appに記録する
- **フロー**: コードベース分析 → モジュール選択 → プロジェクト解決 → Notion親ページ解決 → モジュールごとのドキュメント生成ループ → 結果報告
- **使用インフラ**: Glob/Read/Grep（コード分析）、Notion MCP（ページ作成）、MEX MCP `save_document`（ドキュメント記録）
- **`/document` との関係**: `/document` は git diff（直前コミットの差分）からドキュメントを生成する。`/understand` は既存コードベース全体または指定範囲を分析対象とする。ドキュメント構造・品質基準・Notion/MEX記録方法は統一する。
- **重要な設計意図**: MEX App の「学んだこと」欄はユーザーが後から自分の言葉で書く場所。AIはここに内容を入れない。URLは必ず `source_url` フィールドに分離する。
</background_information>

<instructions>

## Step 1: コードベース分析

### 1.1 プロジェクトタイプ判定

以下の情報を並行して収集する:

1. **プロジェクトタイプの判定**:
   - Glob で `package.json`, `requirements.txt`, `pyproject.toml`, `Cargo.toml`, `go.mod` の存在を確認
   - 複数存在する場合はモノレポ（例: フロントエンド + バックエンド + MCPサーバー）と判定
   - README.md があれば Read でプロジェクト概要を把握

2. **ディレクトリ構造の走査**:
   - Glob で主要ディレクトリを検出: `src/`, `frontend/`, `backend/`, `app/`, `lib/`, `mcp-server/` 等
   - 各ディレクトリ配下の構造を Glob で確認

### 1.2 モジュール自動検出

以下のヒューリスティックでモジュール候補を検出する:

**フロントエンド（React/Next.js等）:**
- `src/components/{Name}/` → 各コンポーネントグループをモジュールとして検出
- `src/api/` or `src/services/` → API クライアントモジュール
- `src/contexts/` or `src/store/` → 状態管理モジュール
- `src/hooks/` → カスタムフックモジュール
- `src/types/` → 型定義（単独モジュールにはせず、関連モジュールに統合）

**バックエンド（FastAPI/Express/Django等）:**
- `app/api/` or `routes/` → API エンドポイントモジュール
- `app/application/` or `services/` → ビジネスロジックモジュール
- `app/domain/` or `models/` → ドメインモジュール
- `app/infrastructure/` → インフラモジュール（DB、外部API等）
- `app/auth/` or `auth/` → 認証モジュール

**MCP サーバー:**
- `mcp-server/src/` → MCP サーバー全体を1モジュールとして扱う

**モジュールのグルーピング:**
- 関連するフロントエンドとバックエンドのファイルを機能単位でグルーピングすることも可
- 例: `backend/app/api/auth.py` + `backend/app/auth/` + `frontend/src/components/Auth/` + `frontend/src/api/auth.ts` → 「認証システム」
- ただし基本はディレクトリ単位で分離し、依存関係はドキュメント内で記述する

### 1.3 モジュール情報の収集と表示

各モジュール候補について:
1. 含まれるファイルを Glob で列挙
2. 主要ファイル（エントリポイント、主要クラス/関数）を Read で概要把握
3. import/require 文から依存関係を推定

以下の形式でユーザーに表示する:

```
## コードベース分析結果

**プロジェクトタイプ**: {Node.js + Python モノレポ 等}

| # | モジュール名 | 責務 | 主要ファイル数 | 使用技術 |
|---|------------|------|-------------|---------|
| 1 | 認証システム | ユーザー認証・JWT管理 | 6 | FastAPI, JWT, bcrypt |
| 2 | プロジェクト管理 | CRUD操作・公開制御 | 4 | SQLAlchemy, FastAPI |
| ... | ... | ... | ... | ... |
```

### 1.4 スコープ指定の処理

`$ARGUMENTS` に応じて分析範囲を決定する:

| 引数 | 動作 |
|------|------|
| なし | 全プロジェクトを分析 → モジュール一覧を表示 → ユーザーに選択を確認 |
| ディレクトリパス（例: `backend/app/api/`） | 指定ディレクトリのみ分析 → モジュール一覧表示 |
| キーワード（例: `auth`, `認証`） | キーワードに関連するモジュールを検出 → 該当モジュールのみ表示 |

モジュール一覧を表示後、ユーザーに確認する:

```
全モジュールのドキュメントを生成しますか？
または番号を指定して特定のモジュールを選択できます（例: 1,3,5）
```

## Step 2: プロジェクト解決

MEX App の `project_id` を解決する。以降のステップで `save_document` に渡す。

1. **`.mex.json` を確認**: プロジェクトルート（gitルート）に `.mex.json` が存在すれば、その `project_id` を使用 → **解決完了、Step 3 へ**

2. **既存プロジェクトを検索**: `mcp__mex__list_projects` でプロジェクト一覧を取得し、`git remote get-url origin` のリポジトリ名やディレクトリ名とタイトルを照合する
   - **一致するプロジェクトが見つかった場合**: その `id` を使用 → `.mex.json` を書き出して **解決完了**

3. **新規作成**: 一致するプロジェクトがない場合、バックエンドAPIで自動作成する:
   - `~/.mex/config.json` から `api_url` と `api_key` を読む
   - Step 1 のコードベース分析結果からプロジェクト情報を構成:
     - `title`: リポジトリ名またはディレクトリ名
     - `description`: README.md の冒頭やコードベース分析から簡潔に（1〜2文）
     - `technologies`: Step 1 で検出した主要技術（5個程度）
     - `repository_url`: `git remote get-url origin`
   - APIを呼び出す:
     ```bash
     curl -s -X POST {api_url}/projects \
       -H "Authorization: Bearer {api_key}" \
       -H "Content-Type: application/json" \
       -d '{"title": "...", "description": "...", "technologies": [...], "repository_url": "...", "status": "in_progress"}'
     ```
   - レスポンスから `id` を取得

4. **`.mex.json` を書き出し**: プロジェクトルートに以下を作成（Step 2, 3 で新たに解決した場合のみ）:
   ```json
   { "project_id": "{解決したID}" }
   ```

## Step 3: Notion 親ページの解決

プロジェクトごとの親ページを解決する:

1. `mcp__notion__notion-search` でプロジェクト名に関連する既存の技術ドキュメント親ページを検索
2. **見つかった場合**: その page_id を親ページとして使用
3. **見つからなかった場合**: `mcp__notion__notion-create-pages` でワークスペース直下に「{プロジェクト名} MEX Docs」という空のページを作成し、その page_id を使用

## Step 4: モジュールごとのドキュメント生成ループ

ユーザーが選択したモジュールを順番に処理する。各モジュールについて以下を実行:

### 4.1 進捗表示

ループ開始前に以下を表示:
```
{N}個のモジュールのドキュメントを生成します。
```

各モジュール処理開始時:
```
[{i}/{N}] 処理中: {モジュール名}...
```

### 4.2 ソースコードの読取

対象モジュールの主要ファイルを Read で読み込む:
- エントリポイント、主要クラス/関数を優先
- バイナリファイル、画像、ロックファイル（package-lock.json, poetry.lock 等）はスキップ
- 1モジュールあたり読み込むファイル数が多い場合は主要ファイル（10ファイル程度）に絞る

### 4.3 ドキュメント内容の生成

`mcp__notion__notion-create-pages` で親ページ配下にドキュメントを作成する。

**タイトル**: `[Understand] {モジュール名}`

**ドキュメント構造**（Notion Markdown形式）:

```
## モジュール概要

**モジュール名**: {モジュール名}
**責務**: {このモジュールが担う機能を1〜2文で説明}
**全体における位置づけ**: {アプリ全体のアーキテクチャにおけるこのモジュールの役割}

**依存関係**:
- → {依存先モジュール名}: {何のために依存しているか}
- ← {依存元モジュール名}: {何のために使われているか}

**構成ファイル**:
- `path/to/file1.ts` — {ファイルの役割を1文で}
- `path/to/file2.ts` — {ファイルの役割を1文で}
- ...

## 技術分解

このモジュールを構成する技術要素を、処理の流れに沿った論理順序で並べます。

- **{技術要素名}** — {モジュール全体におけるこの要素の役割を1文で説明}
- **{技術要素名}** — {役割の説明}
- ...

## 各技術要素の解説

{技術分解で列挙した各要素について、以下の4段階で解説する。コア技術は詳細に、補助的な技術は簡潔に深さを調整する。}

### {技術要素名}

**それは何か**
{技術の定義と概要。専門用語は減らさず、初出時に文脈から意味が理解できる説明を付与する。実装コードの具体的な使用箇所（ファイルパス、関数名）を引用する。}

**なぜ必要か**
{このモジュールにおいてその技術が不可欠な理由。具体的な設定値・ライブラリ名・関数名を引用して説明する。}

**他の選択肢**
{代替技術とそれを選ばなかった理由。実装コードの設計判断に紐づけて説明する。}

**壊れたらどうなるか**
{その技術要素が欠落・故障した場合の具体的な影響。}

### {次の技術要素名}
...

## 想定Q&A

上司や面接官から聞かれそうな質問と回答例を、3段階で整理します。回答はそのまま暗記するのではなく、「結論→理由→具体例」の構造を理解して自分の言葉で説明できるようにしてください。

### 基礎（「そもそも何？」レベル）

**Q: {使用技術の基本的な質問}**
A: **結論**: {1文}　**理由**: {なぜそう言えるか}　**具体例**: {実装コードからの例}

**Q: {もう1問}**
A: ...

### 判断（設計・技術選定の理由）

**Q: {設計判断や技術選定の理由を問う質問。実装コードの具体的な設計判断に紐づける}**
A: **結論**: ...　**理由**: ...　**具体例**: ...

**Q: {もう1問}**
A: ...

### 応用（エッジケース・障害・スケール対応）

**Q: {障害時やスケール時の対応を問う質問}**
A: **結論**: ...　**理由**: ...　**具体例**: ...

**Q: {もう1問}**
A: ...
```

**品質制約（必須）:**
- 技術分解・解説・Q&Aは実装コードの具体的な内容に基づいて生成する。汎用的・テンプレート的な説明のみにしない
- 技術解説では実装コードから具体的な設定値、ライブラリ名、関数名、ファイルパスを引用し、解説の具体性を確保する
- Q&Aの質問は汎用的なもの（「JWTとは？」等）だけでなく、実装コードの具体的な設計判断に紐づいたもの（「トークンの有効期限を60分に設定した理由は？」等）を含める
- 各段階最低2問、合計6問以上のQ&Aを生成する
- セキュリティ関連技術（認証、暗号化、アクセス制御等）が含まれる場合、セキュリティに関する質問を最低1問追加する
- モジュール間の依存関係を概要セクションに必ず含める

**エッジケース処理:**
- ファイル数が非常に少ないモジュール（1-2ファイル）: 技術分解を簡略化し、概要と主要解説のみにしてもよい
- 設定ファイルのみのモジュール: 想定Q&Aを省略可
- 非常に大きいモジュール（20ファイル以上）: 主要ファイル10個程度に絞って分析し、「分析対象を主要ファイルに絞りました」と注記する

- 作成後、レスポンスから Notion ページの URL を取得する
- URLが取得できない場合は `mcp__notion__notion-fetch` でページ情報を取得してURLを構成する

### 4.4 MEX App 記録

**`mcp__mex__save_document` を呼び出す。**

パラメータの設定ルール:
- **project_id**: Step 2 で解決した `project_id`（必須）
- **title**: モジュール名の短い要約（1行、20文字程度）
- **category**: `learning`（既存コードの理解であるため）
- **technologies**: モジュールで使用されている主要技術のリスト（3〜5個程度）
- **source_url**: Step 4.3 で取得した **NotionページのURL**（必須）

**絶対にやらないこと:**
- `record_dev_activity` を使わない（`save_document` を使う）
- URLを title や detail に混ぜない（必ず `source_url` に入れる）

### 4.5 モジュール完了表示

```
[{i}/{N}] 完了: {モジュール名} → {Notion URL}
```

エラーが発生した場合はそのモジュールをスキップし、次のモジュールへ:
```
[{i}/{N}] スキップ: {モジュール名}（{エラー理由}）
```

## Step 5: 結果報告

以下の形式でユーザーに報告:

```
## コードベース理解ドキュメントを生成しました

**プロジェクト**: {プロジェクト名}
**分析モジュール数**: {成功数}/{全体数}
**カテゴリ**: learning

**生成ドキュメント**:
1. [Understand] {モジュール名1} → {Notion URL}
2. [Understand] {モジュール名2} → {Notion URL}
...

**MEX App**: 全{N}件記録完了（source_urlとして保存済み）
```

エラーがあった場合は追記:
```
**スキップしたモジュール**:
- {モジュール名}: {エラー理由}
```

プロジェクトを新規作成した場合:
```
**Note**: プロジェクト「{title}」を新規作成し、`.mex.json` に保存しました。
```

最後に `/learn` への導線:
```
**次のステップ**: 生成されたドキュメントをNotebookLMで学習コンテンツ化できます:
`/learn`
```

## エラーハンドリング

- **`save_document` が見つからない場合**: MCP サーバーの再起動が必要。「MCPサーバーを再起動してください（`/mcp` → mex を restart）」と案内する。
- **プロジェクト作成APIエラー**: `~/.mex/config.json` が存在しない、またはAPIが応答しない場合は、バックエンドの起動状態と設定を確認するよう案内する。トークン期限切れの場合は `/api/auth/login` で再取得を案内する。
- **Notion接続エラー**: エラー内容を表示し、Notion MCPの設定確認を案内する。スキル全体を中断する。
- **MEX App記録エラー**: Notionページは作成済みなのでURLを表示し、手動記録を案内する。次のモジュールへ続行する。
- **Notion API レート制限**: エラーメッセージを表示し、「しばらく待ってから再実行してください」と案内する。
- **バイナリファイル/読取不能ファイル**: そのファイルをスキップし、スキップしたファイルを最終報告に含める。

</instructions>

## 推奨ワークフロー

> **既存プロジェクトの理解には `/understand` → `/learn` の順で実行してください**
>
> `/understand` で技術ドキュメントをNotionに生成し、`/learn` でNotebookLMの学習コンテンツ（フラッシュカード・音声等）に変換します。
>
> ```
> # 既存プロジェクトを理解するフロー
> 1. /understand を実行する（コードベース分析 → Notionドキュメント生成）
> 2. /learn を実行する（NotebookLM学習コンテンツ生成）
> 3. 学んだことをMEX Appの「学んだこと」欄に自分の言葉で記入する
> ```
>
> **`/document` との使い分け:**
> - 既にあるコードを理解したい → `/understand`
> - 新しく書いたコードを記録したい → `/document`（コミット後に実行）

## 使用例

```
/understand                          # 全プロジェクト分析 → モジュール選択
/understand backend                  # backend/ のみ分析
/understand auth                     # 認証関連モジュールのみ
/understand backend/app/api/         # 指定ディレクトリのみ分析
/understand frontend/src/components/ # フロントエンドコンポーネントのみ
```
